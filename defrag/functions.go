// Package defrag solves Day 14 of AoC2017
package defrag

import (
	"fmt"
	"strconv"

	"github.com/emman27/aoc2017/knothash"
)

// PartA returns the number of used squares
func PartA(input string) int {
	count := 0
	for i := 0; i < 128; i++ {
		keystring := input + "-" + strconv.Itoa(i)
		denseHash := knothash.PartB(keystring)
		for _, char := range denseHash {
			bitMask := convertToBitmask(char)
			for _, c := range bitMask {
				if c == '1' {
					count++
				}
			}
		}
	}
	return count
}

// PartB returns the number of islands in the 2d matrix generated by the knothashes
func PartB(input string) int {
	matrix := setupMatrix(input)
	return countIslands(matrix)
}

func countIslands(m [][]bool) int {
	count := 0
	visited := [][]bool{}
	for i := 0; i < 128; i++ {
		visited = append(visited, []bool{})
		for j := 0; j < 128; j++ {
			visited[i] = append(visited[i], false)
		}
	}

	for i := 0; i < len(m); i++ {
		for j := 0; j < len(m[i]); j++ {
			if m[i][j] && !visited[i][j] {
				count++
				markIsland(&m, &visited, i, j)
			}
		}
	}

	return count
}

func markIsland(m, v *[][]bool, i, j int) {
	(*v)[i][j] = true
	if i+1 < len(*m) && (*m)[i+1][j] && !(*v)[i+1][j] {
		markIsland(m, v, i+1, j)
	}
	if i > 0 && (*m)[i-1][j] && !(*v)[i-1][j] {
		markIsland(m, v, i-1, j)
	}
	if j+1 < len((*m)[i]) && (*m)[i][j+1] && !(*v)[i][j+1] {
		markIsland(m, v, i, j+1)
	}
	if j > 0 && (*m)[i][j-1] && !(*v)[i][j-1] {
		markIsland(m, v, i, j-1)
	}
}

func setupMatrix(input string) [][]bool {
	matrix := [][]bool{}
	for i := 0; i < 128; i++ {
		matrix = append(matrix, []bool{})
		keystring := input + "-" + strconv.Itoa(i)
		denseHash := knothash.PartB(keystring)
		for _, char := range denseHash {
			bitMask := convertToBitmask(char)
			for _, c := range bitMask {
				matrix[i] = append(matrix[i], c == '1')
			}
		}
	}
	return matrix
}

func convertToBitmask(c rune) string {
	i, err := strconv.ParseInt(string(c), 16, 0)
	if err != nil {
		panic(err)
	}
	return fmt.Sprintf("%.4b", i)
}
